(- 10 (+ 1 1))
(* (- 1 1) 100)
(* 4 (modulo 8 3))
(modulo (head (list 10 2)) 3)
(max (/ 9 4) 1)
(min 10 10)
(expt (add1 1) 3)
(= 1 (sub1 2)) 
(and (< 1 2) #f)
(or (> 1 2) (>= 1 4))
(not #f)
(xor #t (<= 3 3))
(cond ((< 1 1) 0) (else 100))
(cond ((= 0 1) 'e) ((< 0 1) 'l) ((> 0 1) 'g))
(cond ((not (not #f)) (list 'a 'b)) ((xor #t (= (+ 9 10) 21)) (list 'c 's)))
(if (not #t) 3 4)
(if (<= 0 0) (add1 0) (sub1 1))
(let ((x 0)) x)
(let ((x 1) (y 2) (z 3)) (* (+ x y) z))
(let ((f (lambda (x) x))) (f 1))
(let ((f (lambda (x) (modulo 7 x))) (y 3)) (f y))
(tail (list 6 1 2))
(map (lambda (x) (/ x 2)) (list 0 10 100))
(map (lambda (x) 'z) (list 5 4 3 2 1 0))
(append (list 5 2) (list 8 0))
(filter (lambda (x) (= (modulo x 2) 0)) (list 0 1 2 3 4 5))
(reverse (list 'a 'b 'c 'd))
(append (reverse (list 2 4)) (list 1 3 1))
(foldl (lambda (x y) (max (+ x y) (* x y))) 0 (list 1 2 3))
(reverse (tail (list 3 5 0 1)))
(foldl (lambda (x y) (xor x y)) #t (list #f #t #t))